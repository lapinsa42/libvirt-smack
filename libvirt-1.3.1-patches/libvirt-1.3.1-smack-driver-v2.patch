diff --git a/configure.ac b/configure.ac
index 047ad3b..12d0bb8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -253,6 +253,7 @@ LIBVIRT_CHECK_READLINE
 LIBVIRT_CHECK_SANLOCK
 LIBVIRT_CHECK_SASL
 LIBVIRT_CHECK_SELINUX
+LIBVIRT_CHECK_SMACK
 LIBVIRT_CHECK_SSH2
 LIBVIRT_CHECK_SYSTEMD_DAEMON
 LIBVIRT_CHECK_UDEV
@@ -1535,6 +1536,27 @@ if test "$with_apparmor" = "no"; then
 fi
 AM_CONDITIONAL([WITH_APPARMOR_PROFILES], [test "$with_apparmor_profiles" != "no"])
 
+AC_ARG_WITH([secdriver-smack],
+  [AS_HELP_STRING([--with-secdriver-smack],
+    [use Smack security driver @<:@default=check@:>@])],
+  [],
+  [with_secdriver_smack=check])
+
+if test "$with_smack" != "yes" ; then
+  if test "$with_secdriver_smack" = "check" ; then
+    with_secdriver_smack=no
+  fi
+  if test "$with_secdriver_smack" != "no" ; then
+    AC_MSG_ERROR([You must install the Smack development package in order to compile libvirt])
+  fi
+elif test "with_secdriver_smack" != "no" ; then
+  with_secdriver_smack=yes
+  AC_DEFINE_UNQUOTED([WITH_SECDRIVER_SMACK], 1, [whether Smack security driver is available])
+fi
+AM_CONDITIONAL([WITH_SECDRIVER_SMACK], [test "$with_secdriver_smack" != "no"])
+
+
+
 dnl DTrace static probes
 AC_ARG_WITH([dtrace],
   [AS_HELP_STRING([--with-dtrace],
@@ -2867,6 +2889,7 @@ AC_MSG_NOTICE([Security Drivers])
 AC_MSG_NOTICE([])
 AC_MSG_NOTICE([ SELinux: $with_secdriver_selinux ($SELINUX_MOUNT)])
 AC_MSG_NOTICE([AppArmor: $with_secdriver_apparmor (install profiles: $with_apparmor_profiles)])
+AC_MSG_NOTICE([Smack: $with_secdriver_smack])
 AC_MSG_NOTICE([])
 AC_MSG_NOTICE([Driver Loadable Modules])
 AC_MSG_NOTICE([])
@@ -2897,6 +2920,7 @@ LIBVIRT_RESULT_READLINE
 LIBVIRT_RESULT_SANLOCK
 LIBVIRT_RESULT_SASL
 LIBVIRT_RESULT_SELINUX
+LIBVIRT_RESULT_SMACK
 LIBVIRT_RESULT_SSH2
 LIBVIRT_RESULT_SYSTEMD_DAEMON
 LIBVIRT_RESULT_UDEV
diff --git a/m4/virt-smack.m4 b/m4/virt-smack.m4
new file mode 100644
index 0000000..f23ffdc
--- /dev/null
+++ b/m4/virt-smack.m4
@@ -0,0 +1,48 @@
+dnl The libsmack.so library
+dnl
+dnl Copyright (C) 2013 changyaoh. 
+dnl
+dnl This library is free software; you can redistribute it and/or
+dnl modify it under the terms of the GNU Lesser General Public
+dnl License as published by the Free Software Foundation; either
+dnl version 2.1 of the License, or (at your option) any later version.
+dnl
+dnl This library is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+dnl Lesser General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU Lesser General Public
+dnl License along with this library.  If not, see
+dnl <http://www.gnu.org/licenses/>.
+dnl
+
+AC_DEFUN([LIBVIRT_CHECK_SMACK],[
+  LIBVIRT_CHECK_LIB([SMACK], [smack],
+                    [smack_set_label_for_self], [sys/smack.h])
+
+  AC_ARG_WITH([smack_mount],
+    [AS_HELP_STRING([--with-smack-mount],
+      [set Smack mount point @<:@default=check@:>@])],
+    [],
+    [with_smack_mount=check])
+
+  if test "$with_smack" = "yes"; then
+    AC_MSG_CHECKING([Smack mount point])
+    if test "$with_smack_mount" = "check" || test -z "$with_smack_mount"; then
+      if test -d /sys/fs/smackfs ; then
+        SMACK_MOUNT=/sys/fs/smackfs
+      else
+        SMACK_MOUNT=/smack
+      fi
+    else
+      SMACK_MOUNT=$with_smack_mount
+    fi
+    AC_MSG_RESULT([$SMACK_MOUNT])
+    AC_DEFINE_UNQUOTED([SMACK_MOUNT], ["$SMACK_MOUNT"], [Smack mount point])
+  fi
+])
+
+AC_DEFUN([LIBVIRT_RESULT_SMACK],[
+  LIBVIRT_RESULT_LIB([SMACK])
+])
diff --git a/src/Makefile.am b/src/Makefile.am
index aa5ab69..d367954 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -68,6 +68,10 @@ if WITH_SECDRIVER_APPARMOR
 SECDRIVER_CFLAGS += $(APPARMOR_CFLAGS)
 SECDRIVER_LIBS += $(APPARMOR_LIBS)
 endif WITH_SECDRIVER_APPARMOR
+if WITH_SECDRIVER_SMACK
+SECDRIVER_CFLAGS += $(SMACK_CFLAGS)
+SECDRIVER_LIBS += $(SMACK_LIBS)
+endif WITH_SECDRIVER_SMACK
 
 if WITH_NETWORK
 UUID=$(shell uuidgen 2>/dev/null)
@@ -1005,6 +1009,9 @@ SECURITY_DRIVER_SELINUX_SOURCES =				\
 SECURITY_DRIVER_APPARMOR_SOURCES =				\
 		security/security_apparmor.h security/security_apparmor.c
 
+SECURITY_DRIVER_SMACK_SOURCES =          \
+     security/security_smack.h security/security_smack.c
+
 ACCESS_DRIVER_GENERATED = \
 		access/viraccessapicheck.h \
 		access/viraccessapicheck.c \
@@ -1734,6 +1741,10 @@ if WITH_SECDRIVER_APPARMOR
 libvirt_security_manager_la_SOURCES += $(SECURITY_DRIVER_APPARMOR_SOURCES)
 libvirt_security_manager_la_CFLAGS += $(APPARMOR_CFLAGS)
 endif WITH_SECDRIVER_APPARMOR
+if WITH_SECDRIVER_SMACK
+libvirt_security_manager_la_SOURCES += $(SECURITY_DRIVER_SMACK_SOURCES)
+libvirt_security_manager_la_CFLAGS += $(SMACK_CFLAGS)
+endif WITH_SECDRIVER_SMACK
 
 libvirt_driver_access_la_SOURCES = \
 	$(ACCESS_DRIVER_SOURCES) $(ACCESS_DRIVER_GENERATED)
@@ -1865,6 +1876,7 @@ EXTRA_DIST +=							\
 		$(NWFILTER_DRIVER_SOURCES)			\
 		$(SECURITY_DRIVER_SELINUX_SOURCES)		\
 		$(SECURITY_DRIVER_APPARMOR_SOURCES)		\
+		$(SECURITY_DRIVER_SMACK_SOURCES)    		\
 		$(SECRET_DRIVER_SOURCES)			\
 		$(VBOX_DRIVER_EXTRA_DIST)			\
 		$(VMWARE_DRIVER_SOURCES)			\
diff --git a/src/lxc/lxc_container.c b/src/lxc/lxc_container.c
index c5a70a1..3224331 100644
--- a/src/lxc/lxc_container.c
+++ b/src/lxc/lxc_container.c
@@ -2206,6 +2206,10 @@ static int lxcContainerChild(void *data)
     if (lxcContainerSetID(vmDef) < 0)
         goto cleanup;
 
+    VIR_DEBUG("Setting up security labeling");
+    if (virSecurityManagerSetProcessLabel(argv->securityDriver, vmDef) < 0)
+        goto cleanup;
+
     root = virDomainGetFilesystemForTarget(vmDef, "/");
 
     if (argv->nttyPaths) {
@@ -2254,20 +2258,12 @@ static int lxcContainerChild(void *data)
         goto cleanup;
     }
 
-    /* drop a set of root capabilities */
-    if (lxcContainerDropCapabilities(vmDef, !!hasReboot) < 0)
-        goto cleanup;
-
     if (lxcContainerSendContinue(argv->handshakefd) < 0) {
         virReportSystemError(errno, "%s",
                             _("Failed to send continue signal to controller"));
         goto cleanup;
     }
 
-    VIR_DEBUG("Setting up security labeling");
-    if (virSecurityManagerSetProcessLabel(argv->securityDriver, vmDef) < 0)
-        goto cleanup;
-
     VIR_DEBUG("Setting up inherited FDs");
     VIR_FORCE_CLOSE(argv->handshakefd);
     VIR_FORCE_CLOSE(argv->monitor);
@@ -2275,6 +2271,10 @@ static int lxcContainerChild(void *data)
                              argv->npassFDs, argv->passFDs) < 0)
         goto cleanup;
 
+    /* drop a set of root capabilities */
+    if (lxcContainerDropCapabilities(vmDef, !!hasReboot) < 0)
+        goto cleanup;
+
     ret = 0;
  cleanup:
     VIR_FREE(ttyPath);
@@ -2389,6 +2389,16 @@ int lxcContainerStart(virDomainDefPtr def,
         if (userns_supported()) {
             VIR_DEBUG("Enable user namespace");
             cflags |= CLONE_NEWUSER;
+#ifdef WITH_SMACK
+            if(STREQ(virSecurityManagerGetModel(securityDriver),"smack") &&
+               virSecurityManagerSetChildProcessLabel(securityDriver,
+                                                      def,
+                                                      NULL) < 0) {
+                   virReportError(VIR_ERR_INTERNAL_ERROR,
+                               _("Failed to send label to relabel interface."));
+                   return -1;
+             }
+#endif        
         } else {
             virReportError(VIR_ERR_CONFIG_UNSUPPORTED, "%s",
                            _("Kernel doesn't support user namespace"));
diff --git a/src/lxc/lxc_controller.c b/src/lxc/lxc_controller.c
index 438103a..21b8347 100644
--- a/src/lxc/lxc_controller.c
+++ b/src/lxc/lxc_controller.c
@@ -1476,6 +1476,9 @@ static int virLXCControllerSetupDev(virLXCControllerPtr ctrl)
 
     if (lxcContainerChown(ctrl->def, dev) < 0)
         goto cleanup;
+    
+    if (virSecurityManagerSetImagePathLabel(ctrl->securityManager,ctrl->def,dev) < 0)
+        goto cleanup;
 
     ret = 0;
  cleanup:
@@ -1525,6 +1528,11 @@ static int virLXCControllerPopulateDevices(virLXCControllerPtr ctrl)
         if (lxcContainerChown(ctrl->def, path) < 0)
             goto cleanup;
 
+        if (virSecurityManagerSetImagePathLabel(ctrl->securityManager,
+                                                ctrl->def,
+                                                path) < 0)
+            goto cleanup;
+
         VIR_FREE(path);
     }
 
@@ -2183,6 +2191,14 @@ virLXCControllerSetupDevPTS(virLXCControllerPtr ctrl)
         (lxcContainerChown(ctrl->def, devpts) < 0))
         goto cleanup;
 
+    if ((virSecurityManagerSetImagePathLabel(ctrl->securityManager, 
+                                        ctrl->def, 
+                                        ctrl->devptmx)) < 0 ||
+        (virSecurityManagerSetImagePathLabel(ctrl->securityManager,
+                                        ctrl->def,
+                                        devpts) < 0))
+         goto cleanup;
+
     ret = 0;
 
  cleanup:
@@ -2227,6 +2243,11 @@ virLXCControllerSetupConsoles(virLXCControllerPtr ctrl,
         if (lxcContainerChown(ctrl->def, ttyHostPath) < 0)
             goto cleanup;
 
+        if (virSecurityManagerSetImagePathLabel(ctrl->securityManager,
+                                           ctrl->def,
+                                           ttyHostPath) < 0)
+            goto cleanup;
+
         VIR_FREE(ttyHostPath);
     }
 
diff --git a/src/security/security_apparmor.c b/src/security/security_apparmor.c
index 2cf333d..c013443 100644
--- a/src/security/security_apparmor.c
+++ b/src/security/security_apparmor.c
@@ -986,6 +986,14 @@ AppArmorSetFDLabel(virSecurityManagerPtr mgr,
     return reload_profile(mgr, def, fd_path, true);
 }
 
+static int
+AppArmorSetPathLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                     virDomainDefPtr def ATTRIBUTE_UNUSED,
+                     const char *path ATTRIBUTE_UNUSED)
+{
+    return 0;
+}
+
 static char *
 AppArmorGetMountOptions(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
                         virDomainDefPtr vm ATTRIBUTE_UNUSED)
@@ -1043,6 +1051,7 @@ virSecurityDriver virAppArmorSecurityDriver = {
     .domainRestoreSavedStateLabel       = AppArmorRestoreSavedStateLabel,
 
     .domainSetSecurityImageFDLabel      = AppArmorSetFDLabel,
+    .domainSetSecurityImagePathLabel    = AppArmorSetPathLabel,
     .domainSetSecurityTapFDLabel        = AppArmorSetFDLabel,
 
     .domainGetSecurityMountOptions      = AppArmorGetMountOptions,
diff --git a/src/security/security_dac.c b/src/security/security_dac.c
index a09aba5..1af5175 100644
--- a/src/security/security_dac.c
+++ b/src/security/security_dac.c
@@ -1519,6 +1519,14 @@ virSecurityDACSetImageFDLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
 }
 
 static int
+virSecurityDACSetImagePathLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                              virDomainDefPtr def ATTRIBUTE_UNUSED,
+                              const char *path ATTRIBUTE_UNUSED)
+{
+    return 0;
+}
+
+static int
 virSecurityDACSetTapFDLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
                             virDomainDefPtr def ATTRIBUTE_UNUSED,
                             int fd ATTRIBUTE_UNUSED)
@@ -1601,6 +1609,7 @@ virSecurityDriver virSecurityDriverDAC = {
     .domainRestoreSavedStateLabel       = virSecurityDACRestoreSavedStateLabel,
 
     .domainSetSecurityImageFDLabel      = virSecurityDACSetImageFDLabel,
+    .domainSetSecurityImagePathLabel    = virSecurityDACSetImagePathLabel,
     .domainSetSecurityTapFDLabel        = virSecurityDACSetTapFDLabel,
 
     .domainGetSecurityMountOptions      = virSecurityDACGetMountOptions,
diff --git a/src/security/security_driver.c b/src/security/security_driver.c
index 4800d52..80d39df 100644
--- a/src/security/security_driver.c
+++ b/src/security/security_driver.c
@@ -35,6 +35,10 @@
 # include "security_apparmor.h"
 #endif
 
+#ifdef WITH_SECDRIVER_SMACK
+# include "security_smack.h"
+#endif
+
 #include "security_nop.h"
 
 #define VIR_FROM_THIS VIR_FROM_SECURITY
@@ -48,6 +52,9 @@ static virSecurityDriverPtr security_drivers[] = {
 #ifdef WITH_SECDRIVER_APPARMOR
     &virAppArmorSecurityDriver,
 #endif
+#ifdef WITH_SECDRIVER_SMACK
+    &virSmackSecurityDriver,
+#endif
     &virSecurityDriverNop, /* Must always be last, since it will always probe */
 };
 
diff --git a/src/security/security_driver.h b/src/security/security_driver.h
index 784b0de..d7f9a1d 100644
--- a/src/security/security_driver.h
+++ b/src/security/security_driver.h
@@ -104,6 +104,9 @@ typedef int (*virSecurityDomainSecurityVerify) (virSecurityManagerPtr mgr,
 typedef int (*virSecurityDomainSetImageFDLabel) (virSecurityManagerPtr mgr,
                                                  virDomainDefPtr def,
                                                  int fd);
+typedef int (*virSecurityDomainSetImagePathLabel) (virSecurityManagerPtr mgr,
+                                                   virDomainDefPtr def,
+                                                   const char *path);
 typedef int (*virSecurityDomainSetTapFDLabel) (virSecurityManagerPtr mgr,
                                                virDomainDefPtr def,
                                                int fd);
@@ -165,6 +168,7 @@ struct _virSecurityDriver {
     virSecurityDomainRestoreSavedStateLabel domainRestoreSavedStateLabel;
 
     virSecurityDomainSetImageFDLabel domainSetSecurityImageFDLabel;
+    virSecurityDomainSetImagePathLabel domainSetSecurityImagePathLabel;
     virSecurityDomainSetTapFDLabel domainSetSecurityTapFDLabel;
 
     virSecurityDomainGetMountOptions domainGetSecurityMountOptions;
diff --git a/src/security/security_manager.c b/src/security/security_manager.c
index 07a0522..e254dc1 100644
--- a/src/security/security_manager.c
+++ b/src/security/security_manager.c
@@ -916,6 +916,23 @@ virSecurityManagerSetImageFDLabel(virSecurityManagerPtr mgr,
     return -1;
 }
 
+int
+virSecurityManagerSetImagePathLabel(virSecurityManagerPtr mgr,
+                                    virDomainDefPtr vm,
+                                    const char* path)
+{
+    if (mgr->drv->domainSetSecurityImagePathLabel) {
+        int ret;
+        virObjectLock(mgr);
+        ret = mgr->drv->domainSetSecurityImagePathLabel(mgr,vm,path);
+        virObjectUnlock(mgr);
+        return ret;
+    }
+
+   virReportUnsupportedError();
+   return -1;
+}
+
 
 int
 virSecurityManagerSetTapFDLabel(virSecurityManagerPtr mgr,
diff --git a/src/security/security_manager.h b/src/security/security_manager.h
index e534e31..bfbdd98 100644
--- a/src/security/security_manager.h
+++ b/src/security/security_manager.h
@@ -143,6 +143,9 @@ int virSecurityManagerVerify(virSecurityManagerPtr mgr,
 int virSecurityManagerSetImageFDLabel(virSecurityManagerPtr mgr,
                                       virDomainDefPtr def,
                                       int fd);
+int virSecurityManagerSetImagePathLabel(virSecurityManagerPtr mgr,
+                                        virDomainDefPtr def,
+                                        const char *path);
 int virSecurityManagerSetTapFDLabel(virSecurityManagerPtr mgr,
                                     virDomainDefPtr vm,
                                     int fd);
diff --git a/src/security/security_nop.c b/src/security/security_nop.c
index 951125d..3d4d47a 100644
--- a/src/security/security_nop.c
+++ b/src/security/security_nop.c
@@ -236,6 +236,13 @@ virSecurityDomainSetImageLabelNop(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
     return 0;
 }
 
+static int
+virSecurityDomainSetPathLabelNop(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                                 virDomainDefPtr def ATTRIBUTE_UNUSED,
+                                 const char* path ATTRIBUTE_UNUSED)
+{
+    return 0;
+}
 
 virSecurityDriver virSecurityDriverNop = {
     .privateDataLen                     = 0,
@@ -277,6 +284,7 @@ virSecurityDriver virSecurityDriverNop = {
     .domainRestoreSavedStateLabel       = virSecurityDomainRestoreSavedStateLabelNop,
 
     .domainSetSecurityImageFDLabel      = virSecurityDomainSetFDLabelNop,
+    .domainSetSecurityImagePathLabel    = virSecurityDomainSetPathLabelNop,
     .domainSetSecurityTapFDLabel        = virSecurityDomainSetFDLabelNop,
 
     .domainGetSecurityMountOptions      = virSecurityDomainGetMountOptionsNop,
diff --git a/src/security/security_selinux.c b/src/security/security_selinux.c
index 9e98635..4b510e1 100644
--- a/src/security/security_selinux.c
+++ b/src/security/security_selinux.c
@@ -2459,6 +2459,14 @@ virSecuritySELinuxSetImageFDLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
 }
 
 static int
+virSecuritySELinuxSetImagePathLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                                    virDomainDefPtr def ATTRIBUTE_UNUSED,
+                                    const char *path ATTRIBUTE_UNUSED)
+{
+    return 0;
+}
+
+static int
 virSecuritySELinuxSetTapFDLabel(virSecurityManagerPtr mgr,
                                 virDomainDefPtr def,
                                 int fd)
@@ -2639,6 +2647,7 @@ virSecurityDriver virSecurityDriverSELinux = {
     .domainRestoreSavedStateLabel       = virSecuritySELinuxRestoreSavedStateLabel,
 
     .domainSetSecurityImageFDLabel      = virSecuritySELinuxSetImageFDLabel,
+    .domainSetSecurityImagePathLabel    = virSecuritySELinuxSetImagePathLabel,
     .domainSetSecurityTapFDLabel        = virSecuritySELinuxSetTapFDLabel,
 
     .domainGetSecurityMountOptions      = virSecuritySELinuxGetSecurityMountOptions,
diff --git a/src/security/security_smack.c b/src/security/security_smack.c
new file mode 100644
index 0000000..26bf448
--- /dev/null
+++ b/src/security/security_smack.c
@@ -0,0 +1,1731 @@
+/*
+ * Copyright (C) 2015 .
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Hongliang Liang <hliang@bupt.edu,cn> Changyao Han <changyao@bupt.edu.cn>
+ *   
+ * Updated to libvirt v1.2.15: (Original was written for libvirt v1.1.4)
+ *   Raghuram S Sudhaakar <rssudhaakar@gmail.com>
+ *
+ *   Based on security_selinux.c by James Morris <jmorris@namei.org>
+ *   and security_apparmor.c by Jamie Strandboge <jamie@canonical.com>
+ *
+ *   Smack scurity driver.
+ *
+ */
+
+#include <config.h>
+
+#include <sys/types.h>
+#include <sys/xattr.h>
+#include <sys/stat.h>
+#include <sys/syscall.h>
+#include <fcntl.h>
+#include <sys/smack.h>
+#include <errno.h>
+#include <unistd.h>
+#include <wait.h>
+#include <dirent.h>
+#include <stdlib.h>
+
+
+#include "security_smack.h"
+#include "virerror.h"
+#include "viralloc.h"
+#include "datatypes.h"
+#include "viruuid.h"
+#include "virlog.h"
+#include "virpci.h"
+#include "virusb.h"
+#include "virscsi.h"
+#include "virstoragefile.h"
+#include "virfile.h"
+#include "configmake.h"
+#include "vircommand.h"
+#include "virhash.h"
+#include "virstring.h"
+
+#define VIR_FROM_THIS VIR_FROM_SECURITY
+VIR_LOG_INIT("security.security_smack");
+
+#define SECURITY_SMACK_VOID_DOI     "0"
+#define SECURITY_SMACK_NAME         "smack"
+
+typedef struct _SmackCallbackData SmackCallbackData;
+typedef SmackCallbackData *SmackCallbackDataPtr;
+
+struct _SmackCallbackData {
+	 virSecurityManagerPtr manager;
+	 virSecurityLabelDefPtr secdef;
+};
+
+static char *
+get_label_name(virDomainDefPtr def)
+{
+	 char uuidstr[VIR_UUID_STRING_BUFLEN];
+	 char *name = NULL;
+
+	 virUUIDFormat(def->uuid, uuidstr);
+	 if (virAsprintf(&name, "%s%s", SMACK_PREFIX, uuidstr) < 0)
+		  return NULL;
+
+	 return name;
+}
+
+int 
+getfilelabel(const char *path, char ** label)
+{
+	 char *buf;
+	 ssize_t size;
+	 ssize_t ret;
+
+	 size = SMACK_LABEL_LEN + 1;
+	 buf = malloc(size);
+	 if (!buf)
+		  return -1;
+	 memset(buf, 0, size);
+
+	 ret = getxattr(path, "security.SMACK64", buf, size - 1);
+	 if (ret < 0 && errno == ERANGE) {
+		  char *newbuf;
+
+		  size = getxattr(path, "security.SMACK64", NULL, 0);
+		  if (size < 0)
+				goto out;
+
+		  size++;
+		  newbuf = realloc(buf, size);
+		  if (!newbuf)
+				goto out;
+
+		  buf = newbuf;
+		  memset(buf, 0, size);
+		  ret = getxattr(path, "security.SMACK64", buf, size - 1);
+	 }
+out:
+	 if (ret == 0) {
+		  /* Re-map empty attribute values to errors. */
+		  errno = ENOTSUP;
+		  ret = -1;
+	 }
+	 if (ret < 0)
+		  free(buf);
+	 else
+		  *label = buf;
+	 return ret;
+}
+
+int 
+setfilelabel(const char *path, const char * label)
+{
+	 int ret = setxattr(path, "security.SMACK64", label, strlen(label)+ 1, 0);
+
+	 if (ret < 0 && errno == ENOTSUP) {
+		  char * clabel = NULL;
+		  int err = errno;
+		  if ((getfilelabel(path, &clabel) >= 0) &&
+					 (strcmp(label, clabel) == 0)) {
+				ret = 0;
+		  } else {
+				errno = err;
+		  }
+		  free(clabel);
+	 }
+	 return ret;
+
+}
+
+int 
+fgetfilelabel(int fd, char ** label)
+{
+	 char *buf;
+	 ssize_t size;
+	 ssize_t ret;
+
+	 size = SMACK_LABEL_LEN + 1;
+	 buf = malloc(size);
+	 if (!buf)
+		  return -1;
+	 memset(buf, 0, size);
+
+	 ret = fgetxattr(fd, "security.SMACK64", buf, size - 1);
+	 if (ret < 0 && errno == ERANGE) {
+		  char *newbuf;
+
+		  size = fgetxattr(fd, "security.SMACK64", NULL, 0);
+		  if (size < 0)
+				goto out;
+
+		  size++;
+		  newbuf = realloc(buf, size);
+		  if (!newbuf)
+				goto out;
+
+		  buf = newbuf;
+		  memset(buf, 0, size);
+		  ret = fgetxattr(fd, "security.SMACK64", buf, size - 1);
+	 }
+out:
+	 if (ret == 0) {
+		  /* Re-map empty attribute values to errors. */
+		  errno = ENOTSUP;
+		  ret = -1;
+	 }
+	 if (ret < 0)
+		  free(buf);
+	 else
+		  *label = buf;
+	 return ret;
+}
+
+int 
+fsetfilelabel(int fd, const char * label)
+{
+	 int ret = fsetxattr(fd, "security.SMACK64", label, strlen(label)+ 1, 0);
+
+	 if (ret < 0 && errno == ENOTSUP) {
+		  char * clabel = NULL;
+		  int err = errno;
+		  if ((fgetfilelabel(fd, &clabel) >= 0) &&
+					 (strcmp(label, clabel) == 0)) {
+				ret = 0;
+		  } else {
+				errno = err;
+		  }
+		  free(clabel);
+	 }
+	 return ret;
+}
+
+static int 
+getpidlabel(pid_t pid, char **label)
+{
+
+	 char *result;
+	 int fd;
+	 int ret;
+	 char *path;
+
+	 result = calloc(SMACK_LABEL_LEN + 1, 1);
+	 if (result == NULL)
+		  return -1;
+	 ret = virAsprintf(&path, "/proc/%d/attr/current", pid);
+	 if (ret < 0)
+		  return -1;
+	 fd = open(path, O_RDONLY);
+	 VIR_FREE(path);
+	 if (fd < 0) {
+		  free(result);
+		  return -1;
+	 }
+	 ret = read(fd, result, SMACK_LABEL_LEN);
+	 close(fd);
+	 if (ret < 0) {
+		  free(result);
+		  return -1;
+	 }
+	 *label = result;
+	 return ret;
+
+}
+
+int 
+setsockcreate(const char *label, const char *attr)
+{
+	 int fd;
+	 int ret = -1;
+	 long int tid;
+	 char *path;
+	 tid = syscall(SYS_gettid);
+	 VIR_DEBUG("/proc/self/task/%ld/attr/%s", tid, attr);
+	 ret = virAsprintf(&path, "/proc/self/task/%ld/attr/%s", tid, attr);
+	 if (ret < 0)
+		  return -1;
+
+	 VIR_DEBUG("setsockcreate pid is in %d", getpid());
+	 VIR_DEBUG("real user ID is in %d", getuid());
+	 VIR_DEBUG("effective user ID is in %d", geteuid());
+	 VIR_DEBUG("label from self %s", label);
+	 VIR_DEBUG("location /proc/self/attr/%s", attr);
+
+	 if (label) {
+		  fd = open(path, O_WRONLY | O_CLOEXEC);
+		  VIR_DEBUG("open file %s", path);
+		  VIR_FREE(path);
+		  if (fd < 0) {
+				VIR_DEBUG("open fail");
+				return -1;
+		  }
+		  VIR_DEBUG("open success");
+		  do {
+				ret = write(fd, label, strlen(label) + 1);
+		  } while (ret < 0 && errno == EINTR);
+	 }
+	 else { 
+		  fd = open(path, O_TRUNC);
+		  VIR_FREE(path);
+		  if (fd < 0)
+				return -1;
+		  ret = 0;
+	 }
+
+	 close(fd);
+
+	 return (ret < 0) ? -1 : 0;
+
+}
+
+/*
+static int
+setselfsocklabel(const char * conname,const char * smacklabel)
+{
+
+    int ret = -1;
+    int sfd;
+    DIR *dp;
+    struct dirent *files;
+    struct stat buf;
+
+    if((dp = opendir("/proc/self/fd")) == NULL)
+            return -1;
+
+   while((files = readdir(dp))!=NULL)
+    {
+            if(!strcmp(files->d_name,".") || !strcmp(files->d_name,".."))
+                    continue;
+
+            sfd = atoi(files->d_name);
+
+            if(fstat(sfd,&buf) == -1)
+                    goto done;
+
+            if(S_ISSOCK(buf.st_mode))
+            {
+               if(fsetxattr(sfd,conname,smacklabel,strlen(smacklabel)+ 1,0)< 0)
+                    goto done;
+
+            }
+    }
+
+    ret = 0;
+
+done:
+    return ret;
+
+} 
+*/
+
+static int
+SmackSetFileLabelHelper(const char *path, const char *tlabel)
+{
+	 char * elabel = NULL;
+
+	 VIR_INFO("Setting Smack label on '%s' to '%s'", path, tlabel);
+
+	 if (setfilelabel(path, tlabel) < 0) {
+		  int setfilelabel_errno = errno;
+
+		  if (getfilelabel(path, &elabel) >= 0) {
+				if (STREQ(tlabel, elabel)) {
+					 free(elabel);
+					 /* It's alright, there's nothing to change anyway. */
+					 return 0;
+				}
+				free(elabel);
+		  }
+
+		  /* if the error complaint is related to an image hosted on
+		  * an nfs mount, or a usbfs/sysfs filesystem not supporting
+		  * labelling, then just ignore it & hope for the best.
+			*/
+
+		  if (setfilelabel_errno != EOPNOTSUPP && setfilelabel_errno != ENOTSUP) {
+				virReportSystemError(setfilelabel_errno,
+						  _("unable to set security context '%s' on '%s'"),
+						  tlabel, path);
+				return -1;
+
+		  } else {
+				const char *msg;
+				if ((virFileIsSharedFS(path) == 1)) { 
+					 msg = _("Setting security context '%s' on '%s' not supported. ");
+					 VIR_WARN(msg, tlabel, path);
+				} else { 
+					 VIR_INFO("Setting security context '%s' on '%s' not supported",
+									tlabel, path);
+
+				} 
+
+		  }
+
+	 }
+	 return 0;
+
+}
+
+static int
+SmackSetFileLabel(const char *path, const char *label)
+{
+	 return SmackSetFileLabelHelper(path, label);
+}
+
+static int
+SmackSetSecurityHostdevLabelHelper(const char *file, void *opaque)
+{
+	 virSecurityLabelDefPtr seclabel;
+	 virDomainDefPtr def = opaque;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+	 return SmackSetFileLabel(file, seclabel->imagelabel);
+}
+
+static int
+SmackSetSecurityUSBLabel(virUSBDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file, void *opaque)
+{
+	 return SmackSetSecurityHostdevLabelHelper(file, opaque);
+}
+
+
+static int
+SmackSetSecurityPCILabel(virPCIDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file, void *opaque)
+{
+	 return SmackSetSecurityHostdevLabelHelper(file, opaque);
+}
+
+static int
+SmackSetSecuritySCSILabel(virSCSIDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file, void *opaque)
+{
+	 return SmackSetSecurityHostdevLabelHelper(file, opaque);
+}
+
+
+static int
+SmackRestoreSecurityFileLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  const char *path)
+{
+	 struct stat buf;
+	 int ret = -1;
+	 char *newpath = NULL;
+	 char ebuf[1024];
+
+	 VIR_INFO("Restoring Smack label on '%s'", path);
+
+	 if (virFileResolveLink(path, &newpath) < 0) {
+		  VIR_WARN("cannot resolve symlink %s: %s", path,
+					 virStrerror(errno, ebuf, sizeof(ebuf)));
+		  goto err;
+	 }
+
+	 if (stat(newpath, &buf) != 0) {
+		  VIR_WARN("cannot stat %s: %s", newpath,
+					 virStrerror(errno, ebuf, sizeof(ebuf)));
+		  goto err;
+	 }
+
+	 ret = SmackSetFileLabel(newpath, "smack-unused");
+
+err:
+	 VIR_FREE(newpath);
+	 return ret;
+}
+
+
+static int
+SmackRestoreSecurityUSBLabel(virUSBDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file,
+		  void *opaque)
+{
+	 virSecurityManagerPtr mgr = opaque;
+
+	 return SmackRestoreSecurityFileLabel(mgr, file);
+}
+
+static int
+SmackRestoreSecurityPCILabel(virPCIDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file,
+		  void *opaque)
+{
+	 virSecurityManagerPtr mgr = opaque;
+
+	 return SmackRestoreSecurityFileLabel(mgr, file);
+}
+
+static int
+SmackRestoreSecuritySCSILabel(virSCSIDevicePtr dev ATTRIBUTE_UNUSED,
+		  const char *file,
+		  void *opaque)
+{
+	 virSecurityManagerPtr mgr = opaque;
+
+	 return SmackRestoreSecurityFileLabel(mgr, file);
+}
+
+static int
+SmackRestoreSecurityImageLabelInt(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  virStorageSourcePtr src,
+		  bool migrated)
+{
+	virSecurityLabelDefPtr seclabel;
+
+	seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	if (seclabel == NULL)
+		return -1;
+
+	if (!seclabel->relabel) 
+		return 0;
+
+	if (src->readonly || src->shared)
+		return 0;
+
+	if (!src || src->type == VIR_STORAGE_TYPE_NETWORK)
+		return 0;
+
+	if (migrated) {
+		int ret = virFileIsSharedFS(src->path);
+		if (ret < 0)
+			return -1;
+		if (ret == 1) {
+			VIR_DEBUG("Skipping image label restore on %s because FS is shared", src->path);
+			return 0;
+		}
+
+	}
+
+	return SmackRestoreSecurityFileLabel(mgr, src->path);
+
+}
+
+static int
+SmackFSSetFileLabel(int fd, char *tlabel)
+{
+	 char *elabel = NULL;
+
+	 VIR_INFO("Setting Smack label on fd %d to '%s'", fd, tlabel);
+
+	 if (fsetfilelabel(fd, tlabel) < 0) {
+		  int fsetfilelabel_errno = errno;
+
+		  if (fgetfilelabel(fd, &elabel) >= 0) {
+				if (STREQ(tlabel, elabel)) {
+					 free(elabel);
+					 /* It's alright, there's nothing to change anyway. */
+
+					 return 0;
+				}
+
+				free(elabel);
+		  }
+		  /* if the error complaint is related to an image hosted on
+		  * an nfs mount, or a usbfs/sysfs filesystem not supporting
+		  * labelling, then just ignore it & hope for the best.
+			*/
+		  if (fsetfilelabel_errno != EOPNOTSUPP) {
+				virReportSystemError(fsetfilelabel_errno,
+						  _("unable to set security context '%s' on fd %d"), tlabel, fd);
+				return -1;
+		  } else {
+				VIR_INFO("Setting security label '%s' on fd %d not supported",
+						  tlabel, fd);
+		  }
+	 }
+	 return 0;
+}
+
+
+static int
+SmackSetSecurityHostdevSubsysLabel(virDomainDefPtr def,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 int ret = -1;
+
+	 switch (dev->source.subsys.type) {
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: 
+				{
+					 virUSBDevicePtr usb;
+
+					 if (dev->missing)
+						  return 0;
+
+					 usb = virUSBDeviceNew(dev->source.subsys.u.usb.bus,
+								dev->source.subsys.u.usb.device,
+								vroot);
+					 if (!usb)
+						  goto done;
+
+					 ret = virUSBDeviceFileIterate(usb, SmackSetSecurityUSBLabel, def);
+					 virUSBDeviceFree(usb);
+
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: 
+				{
+					 virPCIDevicePtr pci =
+						  virPCIDeviceNew(dev->source.subsys.u.pci.addr.domain,
+									 dev->source.subsys.u.pci.addr.bus,
+									 dev->source.subsys.u.pci.addr.slot,
+									 dev->source.subsys.u.pci.addr.function);
+
+					 if (!pci)
+						  goto done;
+
+					 if (dev->source.subsys.u.pci.backend
+								== VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {
+						  char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);
+
+						  if (!vfioGroupDev) {
+								virPCIDeviceFree(pci);
+								goto done;
+						  }
+						  ret = SmackRestoreSecurityPCILabel(pci, vfioGroupDev, def);
+						  VIR_FREE(vfioGroupDev);
+					 } else {
+						  ret = virPCIDeviceFileIterate(pci, SmackSetSecurityPCILabel, def);
+					 }
+					 virPCIDeviceFree(pci);
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:
+				{ 
+					 virDomainHostdevSubsysSCSIHostPtr scsihostsrc =
+						  &(dev->source.subsys.u.scsi.u.host);
+					 virSCSIDevicePtr scsi =
+						  virSCSIDeviceNew(NULL,
+									 scsihostsrc->adapter, scsihostsrc->bus,
+									 scsihostsrc->target, scsihostsrc->unit,
+									 dev->readonly, dev->shareable);
+
+					 if (!scsi)
+						  goto done;
+
+					 ret = virSCSIDeviceFileIterate(scsi, SmackSetSecuritySCSILabel, def);
+					 virSCSIDeviceFree(scsi);
+
+					 break;
+				}
+
+		  default:
+				ret = 0;
+				break;
+	 }
+
+done:
+	 return ret;
+}
+
+static int
+SmackSetSecurityHostdevCapsLabel(virDomainDefPtr def,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 int ret = -1;
+	 virSecurityLabelDefPtr seclabel;
+	 char *path;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 switch (dev->source.caps.type) {
+		  case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: 
+				{
+					 if (vroot) {
+						  if (virAsprintf(&path, "%s/%s", vroot,
+										  dev->source.caps.u.storage.block) < 0)
+								return -1;
+					 } else {
+						  if (VIR_STRDUP(path, dev->source.caps.u.storage.block) < 0)
+								return -1;
+					 }
+					 ret = SmackSetFileLabel(path, seclabel->imagelabel);
+					 VIR_FREE(path);
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: 
+				{
+					 if (vroot) {
+						  if (virAsprintf(&path, "%s/%s", vroot,
+										  dev->source.caps.u.misc.chardev) < 0)
+								return -1;
+					 } else {
+						  if (VIR_STRDUP(path, dev->source.caps.u.misc.chardev) < 0)
+								return -1;
+					 }
+					 ret = SmackSetFileLabel(path, seclabel->imagelabel);
+					 VIR_FREE(path);
+					 break;
+				}
+
+		  default: 
+				{
+					 ret = 0;
+					 break;
+				}
+	 }
+
+	 return ret;
+
+}
+
+static int
+SmackSetSecurityHostdevLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 virSecurityLabelDefPtr seclabel;
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 switch (dev->mode) {
+		  case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:
+				return SmackSetSecurityHostdevSubsysLabel(def, dev, vroot);
+
+		  case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:
+				return SmackSetSecurityHostdevCapsLabel(def, dev, vroot);
+
+		  default:
+				return 0;
+
+	 }
+}
+
+static int
+SmackRestoreSecurityHostdevSubsysLabel(virSecurityManagerPtr mgr,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 int ret = -1;
+
+	 switch (dev->source.subsys.type) {
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: 
+				{
+					 virUSBDevicePtr usb;
+
+					 if (dev->missing)
+						  return 0;
+
+					 usb = virUSBDeviceNew(dev->source.subsys.u.usb.bus,
+								dev->source.subsys.u.usb.device,
+								vroot);
+					 if (!usb)
+						  goto done;
+
+					 ret = virUSBDeviceFileIterate(usb, SmackRestoreSecurityUSBLabel, mgr);
+					 virUSBDeviceFree(usb);
+
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: 
+				{
+					 virPCIDevicePtr pci =
+						  virPCIDeviceNew(dev->source.subsys.u.pci.addr.domain,
+									 dev->source.subsys.u.pci.addr.bus,
+									 dev->source.subsys.u.pci.addr.slot,
+									 dev->source.subsys.u.pci.addr.function);
+
+					 if (!pci)
+						  goto done;
+
+					 if (dev->source.subsys.u.pci.backend
+								== VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {
+						  char *vfioGroupDev = virPCIDeviceGetIOMMUGroupDev(pci);
+
+						  if (!vfioGroupDev) {
+								virPCIDeviceFree(pci);
+								goto done;
+						  }
+						  ret = SmackRestoreSecurityPCILabel(pci, vfioGroupDev, mgr);
+						  VIR_FREE(vfioGroupDev);
+					 } else {
+						  ret = virPCIDeviceFileIterate(pci, SmackRestoreSecurityPCILabel, mgr);
+					 }
+					 virPCIDeviceFree(pci);
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI: 
+				{
+					 virDomainHostdevSubsysSCSIHostPtr scsihostsrc =
+						  &(dev->source.subsys.u.scsi.u.host);
+					 virSCSIDevicePtr scsi =
+						  virSCSIDeviceNew(NULL,
+									 scsihostsrc->adapter, scsihostsrc->bus,
+									 scsihostsrc->target, scsihostsrc->unit,
+									 dev->readonly, dev->shareable);
+
+					 if (!scsi)
+						  goto done;
+
+					 ret = virSCSIDeviceFileIterate(scsi, SmackRestoreSecuritySCSILabel, mgr);
+					 virSCSIDeviceFree(scsi);
+
+					 break;
+				}
+
+		  default: 
+				{
+					 ret = 0;
+					 break;
+				}
+	 }
+
+done:
+	 return ret;
+
+}
+
+static int
+SmackRestoreSecurityHostdevCapsLabel(virSecurityManagerPtr mgr,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 int ret = -1;
+	 char *path;
+
+	 switch (dev->source.caps.type) {
+		  case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_STORAGE: 
+				{
+					 if (vroot) {
+						  if (virAsprintf(&path, "%s/%s", vroot,
+										  dev->source.caps.u.storage.block) < 0)
+								return -1;
+					 } else {
+						  if (VIR_STRDUP(path, dev->source.caps.u.storage.block) < 0)
+								return -1;
+					 }
+					 ret = SmackRestoreSecurityFileLabel(mgr, path);
+					 VIR_FREE(path);
+					 break;
+				}
+
+		  case VIR_DOMAIN_HOSTDEV_CAPS_TYPE_MISC: 
+				{
+					 if (vroot) {
+						  if (virAsprintf(&path, "%s/%s", vroot,
+										  dev->source.caps.u.misc.chardev) < 0)
+								return -1;
+					 } else {
+						  if (VIR_STRDUP(path, dev->source.caps.u.misc.chardev) < 0)
+								return -1;
+					 }
+					 ret = SmackRestoreSecurityFileLabel(mgr, path);
+					 VIR_FREE(path);
+					 break;
+				}
+
+		  default:
+				ret = 0;
+				break;
+	 }
+
+	 return ret;
+}
+
+static int
+SmackRestoreSecurityHostdevLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  virDomainHostdevDefPtr dev,
+		  const char *vroot)
+{
+	 virSecurityLabelDefPtr seclabel;	
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 switch (dev->mode) {
+		  case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:
+				return SmackRestoreSecurityHostdevSubsysLabel(mgr, dev, vroot);
+
+		  case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:
+				return SmackRestoreSecurityHostdevCapsLabel(mgr, dev, vroot);
+
+		  default:
+				return 0;
+	 }
+}
+
+/*Called on libvirtd startup to see if Smack is available*/
+static int
+SmackSecurityDriverProbe(const char *virtDriver)
+{
+	 if (!smack_smackfs_path() || NULL == virtDriver)
+		  return SECURITY_DRIVER_DISABLE;
+
+	 return SECURITY_DRIVER_ENABLE;
+
+}
+
+/*Security dirver initialization .*/
+static int
+SmackSecurityDriverOpen(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED)
+{
+	 return 0;
+}
+
+static int
+SmackSecurityDriverClose(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED)
+{
+	 return 0;
+}
+
+static const char *
+SmackSecurityDriverGetModel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED)
+{
+	 return SECURITY_SMACK_NAME;
+}
+
+static const char *
+SmackSecurityDriverGetDOI(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED)
+{
+	 return SECURITY_SMACK_VOID_DOI;
+}
+
+static int
+SmackSecurityVerify(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def)
+{
+	 virSecurityLabelDefPtr seclabel;        
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!STREQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "'%s' model configured for domain, but "
+						  "hypervisor driver is '%s'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+		  return -1;
+	 }
+
+	 if (seclabel->type == VIR_DOMAIN_SECLABEL_STATIC){
+		  if (smack_label_length(seclabel->label) < 0) {
+				virReportError(VIR_ERR_XML_ERROR,
+						  _("Invalid security label %s"), seclabel->label);
+				return -1;
+		  }
+	 }
+
+	 return 0;
+
+}
+
+static int
+SmackSetSecurityDiskLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  virDomainDiskDefPtr disk)
+{
+	 virSecurityLabelDefPtr seclabel;
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 if (disk->src->type == VIR_STORAGE_TYPE_NETWORK)
+		  return 0;
+
+	 VIR_DEBUG("set disk image security label before");
+
+	 if (setxattr(disk->src->path, "security.SMACK64", seclabel->imagelabel,
+						strlen(seclabel->imagelabel) + 1, 0) < 0)
+		  return -1;
+
+	 VIR_DEBUG("disk image %s", disk->src->path);
+	 VIR_DEBUG("set disk image security label after");
+
+	 return 0;
+
+}
+
+static int
+SmackRestoreSecurityDiskLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  virDomainDiskDefPtr disk)
+{
+	 return SmackRestoreSecurityImageLabelInt(mgr, def, disk->src, false);
+}
+
+static int
+SmackSetSecurityImageLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  virStorageSourcePtr src)
+{
+	 virSecurityLabelDefPtr seclabel;
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 if (src->type == VIR_STORAGE_TYPE_NETWORK)
+		  return 0;
+
+	 VIR_DEBUG("set disk image security label before");
+
+	 if (setxattr(src->path, "security.SMACK64", seclabel->imagelabel,
+					strlen(seclabel->imagelabel) + 1, 0) < 0)
+		  return -1;
+
+	 VIR_DEBUG("disk image %s", src->path);
+	 VIR_DEBUG("set disk image security label after");
+
+	 return 0;
+
+}
+
+static int
+SmackRestoreSecurityImageLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  virStorageSourcePtr src)
+{
+	 return SmackRestoreSecurityImageLabelInt(mgr, def, src, false);
+
+}
+
+/*
+static int
+SmackSetSecurityDaemonSocketLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,virDomainDefPtr def)
+{
+
+    virSecurityLabelDefPtr seclabel;
+
+    seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+    if (seclabel == NULL)
+        return -1;
+
+    if (seclabel->label == NULL)
+        return 0;
+
+    if (!STREQ(SECURITY_SMACK_NAME, seclabel->model)) {
+        virReportError(VIR_ERR_INTERNAL_ERROR,
+                       _("security label driver mismatch: "
+                         "'%s' model configured for domain, but "
+                         "hypervisor driver is '%s'."),
+                       seclabel->model, SECURITY_SMACK_NAME);
+        return -1;
+    }
+
+
+    VIR_DEBUG("Setting VM %s socket context %s", def->name, seclabel->label);
+    if (setselfsocklabel("security.SMACK64IPIN",seclabel->label) == -1) {
+        virReportSystemError(errno,
+                             _("unable to set socket smack label '%s'"), seclabel->label);
+        return -1;
+    }
+
+    return 0;
+}
+*/
+
+static int
+SmackSetSecurityDaemonSocketLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED, 
+												virDomainDefPtr vm)
+{
+
+    return 0;
+	 virSecurityLabelDefPtr seclabel;  
+	 char *label = NULL;
+	 int ret = -1;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(vm, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+	 if (!STREQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "'%s' model configured for domain, but "
+						  "hypervisor driver is '%s'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+		  return -1;
+	 }
+
+	 if (smack_new_label_from_self(&label) == -1){
+		  virReportSystemError(errno,
+					 _("unable to get current process context '%s'"), seclabel->label);
+		  goto done; 
+	 }
+
+	 VIR_DEBUG("SmackSetSecurityDaemonSocketLabel is in %d", getpid());
+	 VIR_DEBUG("label from self %s", label);
+
+
+	 if (setsockcreate(label, "sockincreate") == -1) {
+		  virReportSystemError(errno,
+					 _("unable to set socket smack label '%s'"), seclabel->label);
+		  goto done; 
+	 }
+
+	 ret = 0;
+done:
+
+	 free(label);
+	 return ret;
+
+}
+
+static int
+SmackSetSecuritySocketLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr vm)
+{
+
+	 virSecurityLabelDefPtr seclabel;
+    
+    return 0;
+	 seclabel = virDomainDefGetSecurityLabelDef(vm, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+	 if (!STREQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "'%s' model configured for domain, but "
+						  "hypervisor driver is '%s'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+		  return -1;
+	 }
+
+	 VIR_DEBUG("Setting VM %s socket label %s", vm->name, seclabel->label);
+
+	 if (setsockcreate(seclabel->label, "sockoutcreate") == -1) {
+		  virReportSystemError(errno,
+					 _("unable to set socket smack label '%s'"),
+					 seclabel->label);
+		  return -1; 
+	 }
+
+
+	 return 0;
+
+}
+
+static int
+SmackClearSecuritySocketLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def)
+{
+
+	 virSecurityLabelDefPtr seclabel;
+
+    return 0;
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+	 if (!STREQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "'%s' model configured for domain, but "
+						  "hypervisor driver is '%s'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+		  return -1;
+	 }
+
+	 VIR_DEBUG("clear sock label");
+
+	 if (setsockcreate(NULL, "sockincreate") == -1 || 
+			setsockcreate(NULL, "sockoutcreate") == -1) {
+		  virReportSystemError(errno,
+					 _("unable to clear socket smack label '%s'"),
+					 seclabel->label);
+
+		  return -1;
+	 } 
+
+	 return 0;
+}
+
+/*
+*Current called in qemuStartVMDaemon to setup a 'label'. We make the 
+*label based on UUID.
+*this is called on 'start'with RestoreSecurityLabel being called on 
+*shutdown
+ */
+static int
+SmackGenSecurityLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def)
+{
+	 int ret = -1;
+	 char *label_name = NULL;
+	 virSecurityLabelDefPtr seclabel; 
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return ret;
+
+	 VIR_DEBUG("label=%s", virSecurityManagerGetDriver(mgr));
+	 if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&
+				seclabel->label) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
+					 _("security label already defined for VM"));
+		  return ret;
+	 }    
+
+	 if (seclabel->imagelabel) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
+					 _("security image label already defined for VM"));
+		  return ret;
+	 } 
+
+	 if (seclabel->model &&
+				STRNEQ(seclabel->model, SECURITY_SMACK_NAME)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label model %s is not supported with smack"),
+					 seclabel->model);
+		  return ret;
+	 }
+
+	 VIR_DEBUG("type=%d", seclabel->type);
+
+	 if ((label_name = get_label_name(def)) == NULL)
+		  return ret;
+
+	 if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC){
+
+		  /*set process label*/
+		  if (VIR_STRDUP(seclabel->label, label_name) < 0)
+				goto cleanup;
+	 }
+
+	 /*set imagelabel the same as label*/
+	 if (VIR_STRDUP(seclabel->imagelabel, label_name) < 0)
+		  goto cleanup;
+
+	 if (!seclabel->model &&
+				VIR_STRDUP(seclabel->model, SECURITY_SMACK_NAME) < 0)
+		  goto cleanup;
+
+	 ret = 0;
+
+cleanup:
+
+	 if (ret != 0){
+		  if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC)
+				VIR_FREE(seclabel->label);
+		  VIR_FREE(seclabel->imagelabel);
+		  if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC &&
+					 !seclabel->baselabel)
+				VIR_FREE(seclabel->model);
+	 }
+
+	 VIR_FREE(label_name);
+
+	 VIR_DEBUG("model=%s label=%s imagelabel=%s",
+				NULLSTR(seclabel->model),
+				NULLSTR(seclabel->label),
+				NULLSTR(seclabel->imagelabel));
+
+	 return ret;
+
+}
+
+static int
+SmackReserveSecurityLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def ATTRIBUTE_UNUSED,
+		  pid_t pid ATTRIBUTE_UNUSED)
+{
+	 /*Security label is based UUID,*/
+	 return 0;
+}
+
+/*
+*Called on VM shutdown and destroy.
+*/
+static int
+SmackReleaseSecurityLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def)
+{
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->type == VIR_DOMAIN_SECLABEL_DYNAMIC) {
+		  VIR_FREE(seclabel->label);
+		  VIR_FREE(seclabel->model);
+	 }
+	 VIR_FREE(seclabel->imagelabel);
+
+	 return 0;
+
+}
+
+/* Seen with 'virsh dominfo <vm>'. This function only called if the VM is
+* running.
+*/
+static int
+SmackGetSecurityProcessLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def ATTRIBUTE_UNUSED,
+		  pid_t pid,
+		  virSecurityLabelPtr sec)
+{
+
+	 char *label_name = NULL;
+
+	 if (getpidlabel(pid, &label_name) == -1){
+		  virReportSystemError(errno,
+					 _("unable to get PID %d security label"),
+					 pid);
+		  return -1;
+	 }
+
+	 if (strlen(label_name) >= VIR_SECURITY_LABEL_BUFLEN) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label exceeds "
+						  "maximum length: %d"),
+					 VIR_SECURITY_LABEL_BUFLEN - 1);
+		  free(label_name);
+		  return -1; 
+	 }
+
+	 strcpy(sec->label, label_name);
+	 free(label_name);
+	 /*Smack default enforced*/
+	 sec->enforcing = 1;
+
+	 return 0;
+}
+
+static int
+SmackSetSecurityProcessLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def)
+{
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+	 if (STRNEQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "\'%s\' model configured for domain, but "
+						  "hypervisor driver is \'%s\'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+
+		  return -1;
+	 }
+
+	 if (smack_set_label_for_self(seclabel->label) < 0) {
+		  virReportError(errno,
+					 _("unable to set security label '%s'"),
+					 seclabel->label);
+
+		  return -1;
+	 }
+
+	 return 0;
+
+}
+
+static int
+SmackSetSecurityChildProcessLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED, 
+		  virDomainDefPtr def,
+		  virCommandPtr cmd)
+{
+	 virSecurityLabelDefPtr seclabel;
+    int rlbl;
+	 char *smackfs_path = NULL;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+	 if (STRNEQ(SECURITY_SMACK_NAME, seclabel->model)) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("security label driver mismatch: "
+						  "\'%s\' model configured for domain, but "
+						  "hypervisor driver is \'%s\'."),
+					 seclabel->model, SECURITY_SMACK_NAME);
+
+		  return -1;
+	 }
+
+	/*
+	 * Send label to relabel-self interface to allow child to label 
+	 * its self once it finishes setting up. Apply only if interface is
+	 * available and user namespace is enabled.
+	 */
+	
+	if (STREQ(virSecurityManagerGetDriver(mgr), "LXC")) {
+      
+		if(!def->idmap.nuidmap)
+			return 0;
+
+		VIR_DEBUG("Applying label %s to relabel-self interface.",seclabel->label);
+		
+		if(virAsprintf(&smackfs_path,"%s/relabel-self",smack_smackfs_path()) < 0) {
+			virReportError(VIR_ERR_INTERNAL_ERROR,
+							_("Unable to obtain path for smackfs. Is smack enabled? "));
+			return -1;
+		}
+
+		rlbl = open(smackfs_path,O_WRONLY);
+
+		if(rlbl < 0) {
+			virReportError(VIR_ERR_INTERNAL_ERROR,
+							_("Could not open relabel interface \'%s\' for writing. Is it "
+								"enabled in the kernel?"),
+							smackfs_path);
+			return -1;
+		}
+
+		if(write(rlbl, seclabel->label, strlen(seclabel->label)) < 0) {
+			virReportError(VIR_ERR_INTERNAL_ERROR,
+							_("Could not write to relabel interface \'%s\'."),
+							smackfs_path);
+			return -1;
+		}
+
+		VIR_FORCE_CLOSE(rlbl);
+	}
+
+	 /*
+	 *if ((label_name = get_label_name(def)) == NULL)
+	 *    goto cleanup;
+	  */
+
+	 /* save in cmd to be set after fork/before child process is exec'ed */
+	 virCommandSetSmackLabel(cmd, seclabel->label);
+	 VIR_DEBUG("save smack label in cmd %s", seclabel->label);
+
+	 return 0;
+
+}
+
+static int
+SmackSetSecurityAllLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  const char *stdin_path)
+{
+
+	 size_t i;
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 VIR_DEBUG("set image security label before");
+
+	 for (i = 0; i < def->ndisks; i++) {
+		 if (def->disks[i]->src->type == VIR_STORAGE_TYPE_DIR) {
+			 VIR_WARN("Unable to relabel directory tree %s for disk %s",
+					 def->disks[i]->src->path, def->disks[i]->dst);
+			 continue;
+		 }
+
+		 VIR_DEBUG("set image security label");
+
+		 if (SmackSetSecurityImageLabel(mgr,
+					 def, def->disks[i]->src) < 0)
+			 return -1;
+	 }
+
+	 VIR_DEBUG("set image security label after");
+
+	 for (i = 0; i< def->nhostdevs; i++) {
+		  if (SmackSetSecurityHostdevLabel(mgr,
+						  def,
+						  def->hostdevs[i],
+						  NULL) < 0)
+				return -1;
+
+	 }
+
+	 if (stdin_path) {
+		 if (setxattr(stdin_path, "security.SMACK64", seclabel->imagelabel,
+					 strlen(seclabel->imagelabel) + 1, 0)< 0 &&
+				 virFileIsSharedFS(stdin_path) != 1)
+			 return -1;
+	 }
+
+	 return 0;
+
+}
+
+static int
+SmackRestoreSecurityAllLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  bool migrated ATTRIBUTE_UNUSED)
+{
+	 size_t i;
+	 virSecurityLabelDefPtr seclabel;
+
+	 VIR_DEBUG("Restoring security label on %s", def->name);
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 for (i = 0; i < def->ndisks; i++) {
+
+		  if (SmackRestoreSecurityImageLabelInt(mgr,
+						  def,
+						  def->disks[i]->src,
+						  migrated) < 0)
+				/*if (setxattr(def->disks[i]->src,"security.SMACK64","smack-unused",strlen("smack-unused"),0)< 0)*/
+
+				return -1;
+
+	 }
+
+	 return 0;   
+
+}
+
+
+static int
+SmackSetSavedStateLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  const char *savefile) 
+{
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 return SmackSetFileLabel(savefile, seclabel->imagelabel);
+}
+
+static int
+SmackRestoreSavedStateLabel(virSecurityManagerPtr mgr,
+		  virDomainDefPtr def,
+		  const char *savefile)
+{
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (!seclabel->relabel)
+		  return 0;
+
+	 return SmackRestoreSecurityFileLabel(mgr, savefile);
+}
+
+static int
+SmackSetImageFDLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  int fd) 
+{
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->imagelabel == NULL)
+		  return 0;
+
+	 return SmackFSSetFileLabel(fd, seclabel->imagelabel);
+
+}
+
+static int
+SmackSetImagePathLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                       virDomainDefPtr def,
+                       const char *path)
+{
+     virSecurityLabelDefPtr seclabel;
+
+     seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+
+     if (seclabel == NULL)
+        return -1;
+     
+     if (seclabel->imagelabel == NULL)
+        return 0;
+
+     if (setxattr(path, "security.SMACK64", seclabel->imagelabel,
+            strlen(seclabel->imagelabel) + 1, 0) < 0)
+        return -1;
+
+     return 0;
+}
+
+static int
+SmackSetTapFDLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def,
+		  int fd) 
+{
+	 struct stat buf;
+	 virSecurityLabelDefPtr seclabel;
+
+	 seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME);
+	 if (seclabel == NULL)
+		  return -1;
+
+	 if (seclabel->label == NULL)
+		  return 0;
+
+
+	 if (fstat(fd, &buf) < 0) {
+		  virReportSystemError(errno, _("cannot stat tap fd %d"), fd);
+		  return -1;
+	 }
+
+	 if ((buf.st_mode & S_IFMT) != S_IFCHR) {
+		  virReportError(VIR_ERR_INTERNAL_ERROR,
+					 _("tap fd %d is not character device"), fd);
+		  return -1;
+	 }
+
+	 return SmackFSSetFileLabel(fd, seclabel->label);
+
+}
+
+static char *
+SmackGetMountOptions(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  virDomainDefPtr def)
+{
+	 char *opts = NULL;
+	 virSecurityLabelDefPtr seclabel;
+
+	 if ((seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SMACK_NAME))) {
+		 if (!seclabel->imagelabel) {
+			 if (!seclabel->label)
+				 seclabel->imagelabel = get_label_name(def); 
+			 else
+				 seclabel->imagelabel = seclabel->label;
+		 }
+		 if (seclabel->imagelabel &&
+				 virAsprintf(&opts,
+					 ",smackfsdef=\"%s\"",
+					 (const char*) seclabel->imagelabel) < 0) 
+			 return NULL;
+	 }
+
+	 if (!opts && VIR_STRDUP(opts, "") < 0)
+		  return NULL;
+
+	 return opts;
+
+}
+
+static const char *
+SmackGetBaseLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+		  int virtType ATTRIBUTE_UNUSED)
+{
+	 return NULL;
+}
+
+virSecurityDriver virSmackSecurityDriver = {
+	 .privateDataLen                   	 = 0,
+	 .name                               = SECURITY_SMACK_NAME,
+	 .probe                              = SmackSecurityDriverProbe,
+	 .open                               = SmackSecurityDriverOpen,
+	 .close                              = SmackSecurityDriverClose,
+
+	 .getModel                           = SmackSecurityDriverGetModel,
+	 .getDOI                             = SmackSecurityDriverGetDOI,
+
+	 .domainSecurityVerify               = SmackSecurityVerify,
+
+	 .domainSetSecurityDiskLabel         = SmackSetSecurityDiskLabel,
+	 .domainRestoreSecurityDiskLabel     = SmackRestoreSecurityDiskLabel,
+
+	 .domainSetSecurityImageLabel        = SmackSetSecurityImageLabel,
+	 .domainRestoreSecurityImageLabel    = SmackRestoreSecurityImageLabel,
+
+	 .domainSetSecurityDaemonSocketLabel = SmackSetSecurityDaemonSocketLabel,
+
+	 .domainSetSecuritySocketLabel       = SmackSetSecuritySocketLabel,
+	 .domainClearSecuritySocketLabel     = SmackClearSecuritySocketLabel,
+
+	 .domainGenSecurityLabel             = SmackGenSecurityLabel,
+	 .domainReserveSecurityLabel         = SmackReserveSecurityLabel,
+	 .domainReleaseSecurityLabel         = SmackReleaseSecurityLabel,
+
+	 .domainGetSecurityProcessLabel      = SmackGetSecurityProcessLabel,
+	 .domainSetSecurityProcessLabel      = SmackSetSecurityProcessLabel,
+	 .domainSetSecurityChildProcessLabel = SmackSetSecurityChildProcessLabel,
+
+	 .domainSetSecurityAllLabel          = SmackSetSecurityAllLabel,
+	 .domainRestoreSecurityAllLabel      = SmackRestoreSecurityAllLabel,
+
+	 .domainSetSecurityHostdevLabel      = SmackSetSecurityHostdevLabel,
+	 .domainRestoreSecurityHostdevLabel  = SmackRestoreSecurityHostdevLabel,
+
+	 .domainSetSavedStateLabel           = SmackSetSavedStateLabel,
+	 .domainRestoreSavedStateLabel       = SmackRestoreSavedStateLabel,
+
+	 .domainSetSecurityImageFDLabel      = SmackSetImageFDLabel,
+	 .domainSetSecurityImagePathLabel    = SmackSetImagePathLabel,
+	 .domainSetSecurityTapFDLabel        = SmackSetTapFDLabel,
+
+	 .domainGetSecurityMountOptions      = SmackGetMountOptions,
+
+	 .getBaseLabel                       = SmackGetBaseLabel,
+
+};
diff --git a/src/security/security_smack.h b/src/security/security_smack.h
new file mode 100644
index 0000000..2afbf48
--- /dev/null
+++ b/src/security/security_smack.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 .
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Hongliang Liang <hliang@bupt.edu,cn> Changyao Han <changyao@bupt.edu.cn>
+ *
+ */
+
+#ifndef __VIR_SECURITY_SMACK_H__
+# define __VIR_SECURITY_SMACK_H__
+
+# include "security_driver.h"
+
+int getfilelabel(const char *path, char **label);
+int setfilelabel(const char *path, const char *label);
+int fgetfilelabel(int fd, char **label);
+int fsetfilelabel(int fd, const char *label);
+int setsockcreate(const char *label, const char *attr);
+
+
+extern virSecurityDriver virSmackSecurityDriver;
+
+# define SMACK_PREFIX "smack-"
+
+#endif /* __VIR_SECURITY_SMACK_H__ */
diff --git a/src/security/security_stack.c b/src/security/security_stack.c
index 00d1fa7..38551ca 100644
--- a/src/security/security_stack.c
+++ b/src/security/security_stack.c
@@ -495,6 +495,14 @@ virSecurityStackSetImageFDLabel(virSecurityManagerPtr mgr,
 }
 
 static int
+virSecurityStackSetImagePathLabel(virSecurityManagerPtr mgr ATTRIBUTE_UNUSED,
+                                  virDomainDefPtr vm ATTRIBUTE_UNUSED,
+                                  const char *path ATTRIBUTE_UNUSED)
+{
+    return 0;
+} 
+
+static int
 virSecurityStackSetTapFDLabel(virSecurityManagerPtr mgr,
                               virDomainDefPtr vm,
                               int fd)
@@ -659,6 +667,7 @@ virSecurityDriver virSecurityDriverStack = {
     .domainRestoreSavedStateLabel       = virSecurityStackRestoreSavedStateLabel,
 
     .domainSetSecurityImageFDLabel      = virSecurityStackSetImageFDLabel,
+    .domainSetSecurityImagePathLabel    = virSecurityStackSetImagePathLabel,
     .domainSetSecurityTapFDLabel        = virSecurityStackSetTapFDLabel,
 
     .domainGetSecurityMountOptions      = virSecurityStackGetMountOptions,
diff --git a/src/util/vircommand.c b/src/util/vircommand.c
index fe7bf34..7094e89 100644
--- a/src/util/vircommand.c
+++ b/src/util/vircommand.c
@@ -41,6 +41,9 @@
 #if defined(WITH_SECDRIVER_APPARMOR)
 # include <sys/apparmor.h>
 #endif
+#if defined(WITH_SECDRIVER_SMACK)
+# include <sys/smack.h>
+#endif
 
 #define __VIR_COMMAND_PRIV_H_ALLOW__
 #include "vircommandpriv.h"
@@ -134,6 +137,10 @@ struct _virCommand {
 #if defined(WITH_SECDRIVER_APPARMOR)
     char *appArmorProfile;
 #endif
+#if defined(WITH_SECDRIVER_SMACK)
+    char *smackLabel;
+#endif
+
     int mask;
 };
 
@@ -722,6 +729,30 @@ virExec(virCommandPtr cmd)
     }
 # endif
 
+# if defined(WITH_SECDRIVER_SMACK)
+    if (cmd->smackLabel) {
+        VIR_DEBUG("Setting child security label to %s", cmd->smackLabel);
+
+        if (smack_set_label_for_self(cmd->smackLabel) < 0) {
+            virReportSystemError(errno,
+                                 _("unable to set Smack label '%s' "
+                                   "for '%s'"),
+                                 cmd->smackLabel, cmd->args[0]);
+            goto fork_error;
+        }
+    }
+# endif
+
+/*
+ *    if (smack_new_label_from_self(&label) == -1)
+ *    {
+ *            goto fork_error;
+ *    }
+ *    VIR_DEBUG("smack label is %s",label);
+ *    free(label);
+ *
+ *
+ */
     /* The steps above may need to do something privileged, so we delay
      * setuid and clearing capabilities until the last minute.
      */
@@ -1197,6 +1228,35 @@ virCommandSetAppArmorProfile(virCommandPtr cmd,
 }
 
 
+
+/**
+ * virCommandSetSmackLabel:
+ * @cmd: the command to modify
+ * @label: the Smack label to use for the child process
+ *
+ * Saves a copy of @label to use when setting the Smack context
+ * label (write to /proc/self/attr/current ) after the child process has 
+ * been started. If Smack isn't compiled into libvirt, or if label is
+ * NULL, nothing will be done.
+ */
+void
+virCommandSetSmackLabel(virCommandPtr cmd,
+                          const char *label ATTRIBUTE_UNUSED)
+
+{
+      if(!cmd || cmd->has_error)
+	 return;
+      
+#if defined(WITH_SECDRIVER_SMACK)
+          VIR_FREE(cmd->smackLabel);
+	  if (VIR_STRDUP_QUIET(cmd->smackLabel, label) < 0)
+	      cmd->has_error = ENOMEM;
+#endif
+	 return;
+
+}
+
+
 /**
  * virCommandDaemonize:
  * @cmd: the command to modify
@@ -2796,6 +2856,9 @@ virCommandFree(virCommandPtr cmd)
 #if defined(WITH_SECDRIVER_APPARMOR)
     VIR_FREE(cmd->appArmorProfile);
 #endif
+#if defined(WITH_SECDRIVER_SMACK)	
+    VIR_FREE(cmd->smackLabel);
+#endif
 
     VIR_FREE(cmd);
 }
diff --git a/src/util/vircommand.h b/src/util/vircommand.h
index 198da2f..dfc8a65 100644
--- a/src/util/vircommand.h
+++ b/src/util/vircommand.h
@@ -88,6 +88,9 @@ void virCommandSetSELinuxLabel(virCommandPtr cmd,
 void virCommandSetAppArmorProfile(virCommandPtr cmd,
                                   const char *profile);
 
+void virCommandSetSmackLabel(virCommandPtr cmd,
+                               const char *label);
+
 void virCommandDaemonize(virCommandPtr cmd);
 
 void virCommandNonblockingFDs(virCommandPtr cmd);
